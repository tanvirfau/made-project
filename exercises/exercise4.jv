// Pipeline to process temperature data from a remote zip file
pipeline ProcessedTemperaturesPipeline {
    tempHttpFetcher                 // Step 1: Fetch the zip file from the remote server
    -> tempZipExtractor             // Step 2: Extract the zip archive
    -> tempFileSelector             // Step 3: Select the relevant CSV file
    -> tempTextInterpreter          // Step 4: Interpret the CSV file as a text file
    -> tempCSVReader                // Step 5: Read the CSV data with a specified delimiter
    -> renameColumnsToEnglish       // Step 6: Rename German column names to English
    -> renameBatteryTempColumn      // Step 7: Rename the battery temperature column
    -> deleteExtraColumns           // Step 8: Remove unnecessary columns from the dataset
    -> tempTableDefiner             // Step 9: Define the structure and constraints for the table
    -> tempTransformer              // Step 10: Convert temperature column from Celsius to Fahrenheit
    -> batteryTempTransformer       // Step 11: Convert battery temperature column from Celsius to Fahrenheit
    -> tempDataSaver;               // Step 12: Save the processed data into an SQLite database

    // Fetch the zip file from the specified URL
    block tempHttpFetcher oftype HttpExtractor {
        url : "https://www.mowesta.com/data/measure/mowesta-dataset-20221107.zip";
    }

    // Extract the downloaded zip archive
    block tempZipExtractor oftype ArchiveInterpreter {
        archiveType : "zip";
    }

    // Select the relevant CSV file (data.csv) from the extracted archive
    block tempFileSelector oftype FilePicker {
        path : "/data.csv";
    }

    // Interpret the selected file as a text file
    block tempTextInterpreter oftype TextFileInterpreter {
    }

    // Interpret the text file as a CSV with a semicolon delimiter
    block tempCSVReader oftype CSVInterpreter {
        delimiter: ";";
    }

    // Rename German column headers to English for selected columns
    block renameColumnsToEnglish oftype CellWriter {
        at: range A1:E1;
        write : ["device_id", "manufacturer", "model_name", "month_col", "temperature_data"];
    }

    // Rename the battery temperature column
    block renameBatteryTempColumn oftype CellWriter {
        at: cell J1;
        write : ["battery_temp"];
    }

    // Remove unnecessary columns from the dataset
    block deleteExtraColumns oftype ColumnDeleter {
        delete : [column F, column G, column H, column I];
    }

    // Define the table structure and enforce constraints
    block tempTableDefiner oftype TableInterpreter {
        header: false;
        columns: [
            "device_id" oftype posIntType,
            "manufacturer" oftype text,
            "model_name" oftype text,
            "month_col" oftype validMonths,
            "temperature_data" oftype decimal,
            "battery_temp" oftype decimal,
        ];
    }

    // Convert the temperature column from Celsius to Fahrenheit
    block tempTransformer oftype TableTransformer {
        inputColumns : ["temperature_data"];
        outputColumn : "temperature_data";
        uses : celsiusToFahrenheit;
    }

    // Convert the battery temperature column from Celsius to Fahrenheit
    block batteryTempTransformer oftype TableTransformer {
        inputColumns : ["battery_temp"];
        outputColumn : "battery_temp";
        uses : celsiusToFahrenheit;
    }

    // Save the transformed data into an SQLite database
    block tempDataSaver oftype SQLiteLoader {
        table: 'temperatures';
        file: 'temperatures.sqlite';
    }

    // Transformation function to convert Celsius to Fahrenheit
    transform celsiusToFahrenheit {
        from celsius_value oftype decimal;
        to fahrenheit_value oftype decimal;
        fahrenheit_value: (celsius_value * 9/5) + 32;
    }
}

// Value type for positive integers (e.g., IDs)
valuetype posIntType oftype integer {
    constraints : [ posIntConstraint ];
}

// Constraint to ensure values are positive
constraint posIntConstraint on integer :
    value > 0;

// Constraint to ensure month values are within the valid range (1-12)
constraint monthRangeConstraint oftype RangeConstraint {
    lowerBound: 1;                       // Minimum month value
    lowerBoundInclusive: true;           // Inclusive lower bound
    upperBound: 12;                      // Maximum month value
    upperBoundInclusive: true;           // Inclusive upper bound
}

// Value type for valid month values (1-12)
valuetype validMonths oftype integer {
    constraints: [monthRangeConstraint];
}
